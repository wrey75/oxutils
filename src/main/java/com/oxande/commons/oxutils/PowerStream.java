package com.oxande.commons.oxutils;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.Assert;

import java.util.*;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

/**
 * The power stream gives the power to create a stream which is generated by another thread
 * giving you the capability to ensure the memory is not too much used and speed up processing.
 * <p>
 * You must use only the static methods. Note the queue used to store the elements has, by default,
 * a capability of 1000 elements.
 *
 * <pre>
 *     Stream<Element> stream = PowerStream.stream(p -> {
 *           // This part is executed in a thread.
 *           String[] userFilter = {"a*", "b*", "c*", "d*", "e*", "f*", "g*", "h*", "i*", "j*", "k*", "l*", "n*",
 *                                  "o*", "p*", "q*", "r*", "s*", "t*", "u*", "v*", "w*", "x*", "y*", "z*"};
 *           for (String filter : Arrays.asList(userFilter)) {
 *               try {
 *                   List<Element> users = getDao().getAllUsersWithInactiveFrom(filter, null, 10000);
 *                   p.putList(users); // <-- Add stuff in the stream
 *               } catch (SVException | SVStatusException e) {
 *                   // Because consumers are reluctant to accept Exceptions, use the throwException
 *                   // to throw the exception directly. This will emit a PowerStreamException.
 *                   p.throwException(new ConnectorException("Cannot find users for filter " + filter, e));
 *               }
 *           }
 *       });
 * </pre>
 *
 * <p>
 * Note the fact of using a stream will not permit other than {@link RuntimeException}s, this is why
 * a {@link PowerStreamException} is provided and encapsulates the original exception. The mechanism is
 * available through the {@link Pusher#throwException(Throwable)} method.
 * </p>
 *
 * <p>
 * The capacity of the underlying queue is not so important but using a capacity less than 100 elements
 * could create some lagging due to the risk of switching contexts (from the main thread to the provider)
 * too frequently. Nevertheless, the unit tests do not show large differences. You should adapt the capacity
 * with the memory needed.
 * </p>
 *
 * @param <T> the type of elements in the stream.
 */
public class PowerStream<T> implements Iterator<T>, Runnable {
    private static final Logger LOG = LoggerFactory.getLogger(PowerStream.class);

    /**
     * To avoid locking, we need to add of sort of "EOF" at the end of the list, this
     * is why we use a very basic container for the value. Using {@link DataContainer#get()}
     * provides the real value or null when we reached the end of the queue (see
     * {@link DataContainer#isEndOfStream()}).
     *
     * @param <U> the type to store.
     */
    private static class DataContainer<U> implements Supplier<U> {
        private final U value;

        DataContainer(U value) {
            this.value = value;
        }

        public U get() {
            return value;
        }

        /**
         * If the data stored is null, then it is the end of the stream.
         *
         * @return true if the end reached.
         */
        public boolean isEndOfStream() {
            return value == null;
        }
    }

    private final LinkedBlockingQueue<DataContainer<T>> queue;
    private Throwable exception = null;
    private String exceptionMessage = null;
    private final Consumer<Pusher<T>> consumer;
    private DataContainer<T> nextElement = null;

    @SuppressWarnings("serial")
    public static class PowerStreamException extends RuntimeException {
        PowerStreamException(String message, Throwable cause) {
            super(message, cause);
        }
    }

    /**
     * Used to push the data into the stream. An instance of this object is provided through the creation of the
     * {@link PowerStream} (using static methods). You will put information in it and you can throw an exception in it.
     * The exception is, in that case, thrown when you read the stream as a {@link PowerStreamException}. Then you
     * have to care of this.
     *
     * @param <T> the type of the stream.
     */
    public static class Pusher<T> {

        private final PowerStream<T> powerStream;

        private Pusher(PowerStream<T> powerStream) {
            this.powerStream = powerStream;
        }

        /**
         * Put a single object into the stream.
         *
         * @param object the object.
         */
        public void put(T object) {
            Assert.notNull(object, "You are not allowed to put null objects in the stream.");
            try {
                powerStream.queue.put(new DataContainer<T>(object));
            } catch (InterruptedException ex) {
                Thread.currentThread().interrupt();
                throwException("Process has been interrupted while adding data", ex);
            }
        }

        public void put(Optional<T> opt) {
            opt.ifPresent(this::put);
        }

        /**
         * You should never use this method which is mainly used for testing purposes.
         *
         * @param duration the sleep duration in milliseconds
         */
        public void sleep(long duration) {
            try {
                LOG.debug("{} waiting for {} ms...", Thread.currentThread(), duration);
                Thread.sleep(duration);
            } catch (InterruptedException ex) {
                Thread.currentThread().interrupt();
                // throw new PowerStreamException("The processing has been interrupted", ex);
                throwException("Process has been interrupted", ex);
            }
        }

        /**
         * Add a complete collection to the stream. This is a very simple helper in case you
         * generate data by blocks.
         *
         * @param collection the collection to add.
         */
        public void putList(Collection<T> collection) {
            collection.forEach(this::put);
        }

        public void throwException(Throwable t) {
            this.powerStream.exception = t;
            throw new PowerStreamException(this.powerStream.exceptionMessage, t);
        }

        void throwException(String message, Throwable t) {
            this.powerStream.exceptionMessage = message;
            throwException(t);
        }
    }

    /**
     * Create the stream and starts the consumer.
     *
     * @param consumer the consumer to generate data
     * @param capacity the maximum capacity to block when necessary.
     */
    private PowerStream(Consumer<Pusher<T>> consumer, int capacity) {
        this.queue = new LinkedBlockingQueue<>(capacity);
        this.consumer = consumer;
        Thread t = new Thread(this);

        LOG.info("Thread {} created...", t);
        t.start();
    }


    @Override
    public final void run() {
        Pusher<T> pusher = new Pusher<>(this);
        consumer.accept(pusher);
        try {
            // Push the end of list element
            this.queue.put(new DataContainer<>(null));
        } catch (InterruptedException e) {
            pusher.throwException(e);
        }
    }

    /**
     * Returns {@code true} if the iteration has more elements.
     * (In other words, returns {@code true} if {@link #next} would
     * return an element rather than throwing an exception.)
     *
     * <p>
     * The internal implementation is also in charge to get the next element
     * to check if a new element is available then this method can block when
     * requested, whereas the {@link #next()} method will not block.
     * </p>
     *
     * @return {@code true} if the iteration has more elements
     */
    @Override
    public boolean hasNext() {
        if (this.exception != null) {
            String msg = Optional.ofNullable(this.exceptionMessage).orElse("The processing failed");
            throw new PowerStreamException(msg, this.exception);
        }

        if (nextElement != null) {
            // We already have the next element ready.
            return !nextElement.isEndOfStream();
        }

        try {
            this.nextElement = this.queue.take();
        } catch (InterruptedException e) {
            throw new PowerStreamException("Processing interrupted.", e);
        }
        return !nextElement.isEndOfStream();
    }

    /**
     * Returns the next element in the iteration.
     *
     * @return the next element in the iteration
     * @throws NoSuchElementException if the iteration has no more elements
     */
    @Override
    public T next() {
        if (!hasNext()) {
            throw new NoSuchElementException();
        }
        DataContainer<T> ret = nextElement;
        nextElement = null; // Reset...
        return ret.get();
    }

    /**
     * Retrieve an iterator for the consumer provided. We use a blocking queue under the hoods
     * of 1000 elements.
     *
     * @param consumer the consumer
     * @param <R> the type of objects to get in the iterator.
     * @return an iterator ready to use.
     */
    public static <R> Iterator<R> iterator(Consumer<Pusher<R>> consumer) {
        return iterator(consumer, 1000);
    }

    /**
     * Retrieve an iterator for the consumer provided.
     *
     * @param consumer the consumer
     * @param capacity the capacity of the queue.
     * @param <R> the type of objects to get in the iterator.
     * @return an iterator ready to use.
     */
    public static <R> Iterator<R> iterator(Consumer<Pusher<R>> consumer, int capacity) {
        PowerStream<R> powerStream = new PowerStream<>(consumer, capacity);
        return powerStream;
    }

    public static <R> Stream<R> stream(Consumer<Pusher<R>> consumer) {
        return stream(consumer, 1000);
    }

    /**
     * Retrieve a stream for the consumer provided. If you just do stuff on elements without filtering
     * or other stuff linked to {@link Stream}s, you should use the simpler iterator.
     *
     * @param consumer the consumer
     * @param capacity the capacity of the queue.
     * @param <R> the type of objects to get in the iterator.
     * @return an stream ready to use.
     * @see #iterator(Consumer, int)
     */
    public static <R> Stream<R> stream(Consumer<Pusher<R>> consumer, int capacity) {
        return StreamSupport.stream(
                Spliterators.spliteratorUnknownSize(iterator(consumer, capacity), Spliterator.ORDERED),
                false);
    }

}
